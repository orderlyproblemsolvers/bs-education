import{computed as e,toValue as a,getCurrentInstance as t,onServerPrefetch as r,ref as n,shallowRef as o,nextTick as s,unref as i,toRef as c,defineComponent as l,createElementBlock as u,provide as d,cloneVNode as f,h as y}from"vue";import{g as p,o as v,p as b}from"./server.mjs";const _={trailing:!0};function debounce(e,a=25,t={}){if(t={..._,...t},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let r,n,o,s,i=[];const applyFn=(a,r)=>(o=async function(e,a,t){return await e.apply(a,t)}(e,a,r),o.finally(()=>{if(o=null,t.trailing&&s&&!n){const e=applyFn(a,s);return s=null,e}}),o),debounced=function(...e){return t.trailing&&(s=e),o||new Promise(o=>{const c=!n&&t.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const a=t.leading?r:applyFn(this,e);s=null;for(const e of i)e(a);i=[]},a),c?(r=applyFn(this,e),o(r)):i.push(o)})},_clearTimeout=e=>{e&&(clearTimeout(e),n=null)};return debounced.isPending=()=>!!n,debounced.cancel=()=>{_clearTimeout(n),i=[],s=null},debounced.flush=()=>{if(_clearTimeout(n),!s||o)return;const e=s;return s=null,applyFn(this,e)},debounced}l({name:"ServerPlaceholder",render:()=>u("div")});const D=Symbol.for("nuxt:client-only");function useAsyncData(...l){const u="string"==typeof l[l.length-1]?l.pop():void 0;(function(e,a){if("string"==typeof e)return!1;if("object"==typeof e&&null!==e)return!1;if("function"==typeof e&&"function"==typeof a)return!1;return!0})(l[0],l[1])&&l.unshift(u);let[d,f,y={}]=l;const _=e(()=>a(d));if("string"!=typeof _.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof f)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const D=p();function createInitialFetch(){const a={cause:"initial",dedupe:y.dedupe};return D._asyncData[_.value]?._init||(a.cachedData=y.getCachedData(_.value,D,{cause:"initial"}),D._asyncData[_.value]=function(a,t,r,l,u){a.payload._errors[t]??=void 0;const d=l.getCachedData!==getDefaultCachedData,f=r,y=l.deep?n:o,p=void 0!==u,v=a.hook("app:data:refresh",async e=>{e&&!e.includes(t)||await _.execute({cause:"refresh:hook"})}),_={data:y(p?u:l.default()),pending:e(()=>"pending"===_.status.value),error:c(a.payload._errors,t),status:o("idle"),execute:(...e)=>{const[r,n]=e,o=r&&void 0===n&&"object"==typeof r?r:{};if(a._asyncDataPromises[t]&&"defer"===(o.dedupe??l.dedupe))return a._asyncDataPromises[t];{const e="cachedData"in o?o.cachedData:l.getCachedData(t,a,{cause:o.cause??"refresh:manual"});if(void 0!==e)return a.payload.data[t]=_.data.value=e,_.error.value=void 0,_.status.value="success",Promise.resolve(e)}_._abortController&&_._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),_._abortController=new AbortController,_.status.value="pending";const s=new AbortController,c=new Promise((e,t)=>{try{const r=o.timeout??l.timeout,n=function(e,a,t){const r=e.filter(e=>!!e);if("number"==typeof t&&t>=0){const e=AbortSignal.timeout?.(t);e&&r.push(e)}if(AbortSignal.any)return AbortSignal.any(r);const n=new AbortController;for(const e of r)if(e.aborted){const a=e.reason??new DOMException("Aborted","AbortError");try{n.abort(a)}catch{n.abort()}return n.signal}const onAbort=()=>{const e=r.find(e=>e.aborted),a=e?.reason??new DOMException("Aborted","AbortError");try{n.abort(a)}catch{n.abort()}};for(const e of r)e.addEventListener?.("abort",onAbort,{once:!0,signal:a});return n.signal}([_._abortController?.signal,o?.signal],s.signal,r);if(n.aborted){const e=n.reason;return void t(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))}return n.addEventListener("abort",()=>{const e=n.reason;t(e instanceof Error?e:new DOMException(String(e??"Aborted"),"AbortError"))},{once:!0,signal:s.signal}),Promise.resolve(f(a,{signal:n})).then(e,t)}catch(e){t(e)}}).then(async e=>{let r=e;l.transform&&(r=await l.transform(e)),l.pick&&(r=function(e,a){const t={};for(const r of a)t[r]=e[r];return t}(r,l.pick)),a.payload.data[t]=r,_.data.value=r,_.error.value=void 0,_.status.value="success"}).catch(e=>a._asyncDataPromises[t]&&a._asyncDataPromises[t]!==c||_._abortController?.signal.aborted?a._asyncDataPromises[t]:"undefined"!=typeof DOMException&&e instanceof DOMException&&"AbortError"===e.name?(_.status.value="idle",a._asyncDataPromises[t]):(_.error.value=b(e),_.data.value=i(l.default()),void(_.status.value="error"))).finally(()=>{s.abort(),delete a._asyncDataPromises[t]});return a._asyncDataPromises[t]=c,a._asyncDataPromises[t]},_execute:debounce((...e)=>_.execute(...e),0,{leading:!0}),_default:l.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{v(),a._asyncData[t]?._init&&(a._asyncData[t]._init=!1),d||s(()=>{a._asyncData[t]?._init||(clearNuxtDataByKey(a,t),_.execute=()=>Promise.resolve())})}};return _}(D,_.value,f,y,a.cachedData)),()=>D._asyncData[_.value].execute(a)}y.server??=!0,y.default??=getDefault,y.getCachedData??=getDefaultCachedData,y.lazy??=!1,y.immediate??=!0,y.deep??=v.deep,y.dedupe??="cancel",y._functionName,D._asyncData[_.value];const m=createInitialFetch();D._asyncData[_.value]._deps++;if(!1!==y.server&&D.payload.serverRendered&&y.immediate){const e=m();t()?r(()=>e):D.hook("app:created",async()=>{await e})}const h={data:writableComputedRef(()=>D._asyncData[_.value]?.data),pending:writableComputedRef(()=>D._asyncData[_.value]?.pending),status:writableComputedRef(()=>D._asyncData[_.value]?.status),error:writableComputedRef(()=>D._asyncData[_.value]?.error),refresh:(...e)=>{if(!D._asyncData[_.value]?._init){return createInitialFetch()()}return D._asyncData[_.value].execute(...e)},execute:(...e)=>h.refresh(...e),clear:()=>{const e=D._asyncData[_.value];if(e?._abortController)try{e._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{e._abortController=void 0}clearNuxtDataByKey(D,_.value)}},g=Promise.resolve(D._asyncDataPromises[_.value]).then(()=>h);return Object.assign(g,h),g}function writableComputedRef(a){return e({get:()=>a()?.value,set(e){const t=a();t&&(t.value=e)}})}function clearNuxtDataByKey(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=void 0),e._asyncData[a]&&(e._asyncData[a].data.value=i(e._asyncData[a]._default()),e._asyncData[a].error.value=void 0,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]=void 0)}l({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(e,{slots:a,attrs:r}){const n=o(!1),s=t();return s&&(s._nuxtClientOnly=!0),d(D,!0),()=>{if(n.value){const e=a.default?.();return e&&1===e.length?[f(e[0],r)]:e}const t=a.fallback||a.placeholder;if(t)return y(t);const o=e.fallback||e.placeholder||"",s=e.fallbackTag||e.placeholderTag||"span";return u(s,r,o)}}});const getDefault=()=>{},getDefaultCachedData=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0;export{useAsyncData as u};
//# sourceMappingURL=asyncData-CWCkQ0Ta.mjs.map
